%skeleton "lalr1.cc"
%define parser_class_name {ObjParser}
%define api.value.type variant
%define parse.assert

%code requires{
    #include <glm/glm.hpp>
    #include "debug.h"

    class ObjLexer;
    class ObjReader;

    enum class Keyword;

    // "Temporary" ugly hack
    #ifndef YY_NULLPTR
    #define YY_NULLPTR nullptr
    #endif

    // Some structures needed for the grammar
    struct IndexUv {
        unsigned int index;
        unsigned int uv;
        IndexUv() : index(0), uv(0) { }
    };

    struct IndexNormal {
        unsigned int index;
        unsigned int normal;
        IndexNormal() : index(0), normal(0) { }
    };

    struct IndexUvNormal {
        unsigned int index;
        unsigned int uv;
        unsigned int normal;
        explicit IndexUvNormal(unsigned int i = 0, unsigned int u = 0, unsigned int n = 0) : index(i), uv(u), normal(n) { }
    };

    struct Face {
        IndexUvNormal v1;
        IndexUvNormal v2;
        IndexUvNormal v3;
    };
}

%debug
%param { ObjLexer& lexer }
%param { ObjReader& reader }

%define api.token.prefix {TOK_}
%token<Keyword>         MTLLIB OBJECT VERTEX NORMAL USEMTL SMOOTH FACE GROUP
%token<std::string>     IDENT
%token<float>           FLOAT
%token<int>             INT
%token<char>            SLASH
%token                  END 0

%code {
}

%type <float>         coord
%type <int>           index
%type <unsigned int>  vertex_index
%type <IndexUv>       vertex_index_uv
%type <IndexUvNormal> vertex_index_uv_normal
%type <IndexNormal>   vertex_index_normal

%start obj_spec

%code {
    #include "obj.h"
    static int yylex(yy::ObjParser::semantic_type* lval, ObjLexer& lexer, ObjReader& reader);

    #define TRANSLATE_VERTEX_INDEX(i) ( (i < 0) ? reader.m_currentGroup->vertices.size()  + i : i)
    #define TRANSLATE_NORMAL_INDEX(i) ( (i < 0) ? reader.m_currentGroup->normals.size()   + i : i)
    #define TRANSLATE_UV_INDEX(i)     ( (i < 0) ? reader.m_currentGroup->texCoords.size() + i : i)
}

%%

obj_spec: line_list END

line_list: line_list obj_line
           | obj_line

index: INT {
        // Apply correction because of indices starting at 1
        $$ = ($1 <= 0) ? $1 : $1 - 1;
}

coord: FLOAT { DBG(std::cout << "Bison : float coord " << $1 << std::endl;) $$ = $1; }
       | INT { $$ = static_cast<float>($1); }

obj_line: mtllib_spec
          | usemtl_spec
          | obj_decl
          | vertex_spec
          | normal_spec
          | smoothing_spec
          | face_spec
          | group_spec

mtllib_spec: MTLLIB file_list

usemtl_spec: USEMTL IDENT

obj_decl: OBJECT IDENT { }

file_list: IDENT 
           | file_list IDENT 

normal_spec: NORMAL coord coord coord {
        DBG(std::cout << "Bison : normal vec3" << std::endl;)
        reader.add_normal(glm::vec3($2, $3, $4));
}

vertex_spec: VERTEX coord coord coord { 
        DBG(std::cout << "Bison : vec3" << std::endl;)
        reader.add_vertex(glm::vec3($2, $3, $4));
 }
             | VERTEX coord coord coord coord {
        DBG(std::cout << "Bison : vec4" << std::endl;)
        reader.add_vertex(glm::vec4($2, $3, $4, $5));
 }

face_spec: FACE vertex_index vertex_index vertex_index {
        DBG(std::cout << "Bison : face (vertex indices)" << std::endl;)
        Face f;
        f.v1 = IndexUvNormal($2, 0, 0);
        f.v2 = IndexUvNormal($3, 0, 0);
        f.v3 = IndexUvNormal($4, 0, 0);
        reader.add_face(f);
}
           | FACE vertex_index_uv vertex_index_uv vertex_index_uv {
        DBG(std::cout << "Bison : face (vertex indices and uvs)" << std::endl;)
        Face f;
        f.v1 = IndexUvNormal($2.index, $2.uv, 0);
        f.v2 = IndexUvNormal($3.index, $3.uv, 0);
        f.v3 = IndexUvNormal($4.index, $4.uv, 0);
        reader.add_face(f);
}
           | FACE vertex_index_uv_normal vertex_index_uv_normal vertex_index_uv_normal {
        DBG(std::cout << "Bison : face (vertex indices, uvs and normals)" << std::endl;)
        Face f;
        f.v1 = IndexUvNormal($2.index, $2.uv, $2.normal);
        f.v2 = IndexUvNormal($3.index, $3.uv, $3.normal);
        f.v3 = IndexUvNormal($4.index, $4.uv, $4.normal);
        reader.add_face(f);
}
           | FACE vertex_index_normal vertex_index_normal vertex_index_normal {
        DBG(std::cout << "Bison : face (vertex indices ans normals)" << std::endl;)
        Face f;
        f.v1 = IndexUvNormal($2.index, 0, $2.normal);
        f.v2 = IndexUvNormal($3.index, 0, $3.normal);
        f.v3 = IndexUvNormal($4.index, 0, $4.normal);
        reader.add_face(f);
}

vertex_index: index { $$ = TRANSLATE_VERTEX_INDEX($1); }

vertex_index_uv: vertex_index SLASH index {
    IndexUv iu;
    iu.index = $1;
    iu.uv = TRANSLATE_UV_INDEX($3);
    $$ = iu;
}

vertex_index_uv_normal: vertex_index SLASH index SLASH index {
    IndexUvNormal iun;
    iun.index = $1;
    iun.uv = TRANSLATE_UV_INDEX($3);
    iun.normal = TRANSLATE_NORMAL_INDEX($5);
    $$ = iun;
}

vertex_index_normal: vertex_index SLASH SLASH index {
    IndexNormal in;
    in.index = $1;
    in.normal = TRANSLATE_NORMAL_INDEX($4);
    $$ = in;
}

group_spec: GROUP IDENT { DBG(std::cout << "Bison : group" << std::endl;) }

smoothing_spec: SMOOTH index { DBG(std::cout << "Bison : smoothing" << std::endl;) }
                | SMOOTH IDENT { DBG(std::cout << "Bison : smoothing off?" << std::endl;) }

%%

#include "obj_lexer.h"

void yy::ObjParser::error(std::string const& err) {
    std::cerr << "Bison error : " << err << std::endl;
}

static int yylex(yy::ObjParser::semantic_type* lval, ObjLexer& lexer, ObjReader& reader){
    return lexer.yylex(lval);
}
